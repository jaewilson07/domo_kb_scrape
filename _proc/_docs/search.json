[
  {
    "objectID": "client/get_data.html",
    "href": "client/get_data.html",
    "title": "get_data",
    "section": "",
    "text": "source\n\nget_data\n\n get_data (url:str, method:str, auth:domolibrary.client.DomoAuth.DomoAuth,\n           content_type:Optional[dict]=None, headers:Optional[dict]=None,\n           session:Optional[aiohttp.client.ClientSession]=None,\n           body:Union[dict,str,NoneType]=None, params:Optional[dict]=None,\n           debug_api:bool=False)\n\nasync wrapper for asyncio requests\n\nsample implementation of get_data\nDuring execution get_data() will attempt to retrieve exchange credentials for an auth token using the dmda.DomoFullAuth.get_auth_token() method.\nThen the appropriate headers will be passed to the request.\n\nimport os\n\nfull_auth = dmda.DomoFullAuth(\n    domo_instance=\"domo-dojo\",\n    domo_username=\"jae@onyxreporting.com\",\n    domo_password=os.environ[\"DOJO_PASSWORD\"]\n)\n\nurl = \"https://domo-dojo.domo.com/api/content/v2/users/me\"\n\ntry:\n    res = await get_data(url=url, method=\"get\", auth=full_auth)\n    print(res)\n\nexcept Exception as e:\n    print(e)\n\nResponseGetData(status=401, response='Unauthorized', is_success=False)\n\n\n\nsource\n\n\n\nLooperError\n\n LooperError (loop_stage:str, message)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nlooper\n\n looper (auth:domolibrary.client.DomoAuth.DomoAuth,\n         session:aiohttp.client.ClientSession, url, offset_params,\n         arr_fn:<built-infunctioncallable>, loop_until_end:bool=False,\n         method='POST', body:dict=None, fixed_params:dict=None,\n         offset_params_in_body:bool=False, body_fn=None, limit=1000,\n         skip=0, maximum=2000, debug_api:bool=False,\n         debug_loop:bool=False)"
  },
  {
    "objectID": "client/responsegetdata.html",
    "href": "client/responsegetdata.html",
    "title": "ResponseGetData",
    "section": "",
    "text": "source\n\nResponseGetData\n\n ResponseGetData (status:int, response:<built-infunctionany>,\n                  is_success:bool, auth:dict=None)\n\npreferred response class for all API Requests\n\nrgd = ResponseGetData(status=200, response=\"test\", is_success=True)\nrgd\n\nResponseGetData(status=200, response='test', is_success=True)\n\n\n\n\nClassmethods from Response objects by library\nThis code base supports two API request libraries, requests.request (synchronous) and aiohttp.ClientRequest (asynchronous) this can be extended as new libraries emerge with different performance characteristics.\n\nsource\n\nResponseGetData._from_requests_response\n\n ResponseGetData._from_requests_response (res:requests.models.Response)\n\nreturns ResponseGetData\n\n\n\n\nType\nDetails\n\n\n\n\nres\nResponse\nrequests response object\n\n\nReturns\nResponseGetData\n\n\n\n\n\n# test _from_requests_response returns ResponseGetData class\nimport os\nimport requests\n\nurl = f\"https://domo-dojo.domo.com/api/content/v2/authentication\"\n\ntokenHeaders = {\"Content-Type\": \"application/json\"}\n\nbody = {\n    \"method\": \"password\",\n    \"emailAddress\": \"jae@onyxreporting.com\",\n    \"password\": os.environ[\"DOJO_PASSWORD\"],\n}\n\nres = requests.request(method=\"POST\", url=url, json=body, headers=tokenHeaders)\n\nprint(res.status_code)\n\ntest_res = ResponseGetData._from_requests_response(res)\ntest_res.__dict__.keys()\n\n200\n\n\ndict_keys(['status', 'response', 'is_success', 'auth'])\n\n\n\nsource\n\n\nResponseGetData._from_aiohttp_response\n\n ResponseGetData._from_aiohttp_response\n                                         (res:aiohttp.client_reqrep.Client\n                                         Response, auth:Optional[<built-\n                                         infunctionany>]=None)\n\nasync method returns ResponseGetData\n\n# test _from_aiohttp_response returns ResponseGetData class\n\nimport os\nimport requests\n\n\nurl = f\"https://domo-dojo.domo.com/api/content/v2/authentication\"\n\nbody = {\n    \"method\": \"password\",\n    \"emailAddress\": \"jae@onyxreporting.com\",\n    \"password\": os.environ[\"DOJO_PASSWORD\"],\n}\n\nsession = aiohttp.ClientSession()\nres = await session.post(url=url, json=body)\nawait session.close()\n\nprint(res.status)\n\ntest_res = await ResponseGetData._from_aiohttp_response(res)\ntest_res.__dict__.keys()\n\n200\n\n\ndict_keys(['status', 'response', 'is_success', 'auth'])"
  },
  {
    "objectID": "routes/activity_log.html",
    "href": "routes/activity_log.html",
    "title": "Activity Log Routes",
    "section": "",
    "text": "source\n\nget_activity_log_object_types\n\n get_activity_log_object_types (auth:domolibrary.client.DomoAuth.DomoAuth)\n\nretrieves a list of valid objectTypes that can be used to search the activity_log API\n\nsample implementation of get_activity_log_object_types\n\nimport os\nimport pandas as pd\n\ntry:\n    token_auth = dmda.DomoTokenAuth(\n        domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n        domo_instance=\"domo-dojo\",\n    )\n\n    al_objecttype_res = await get_activity_log_object_types(auth=token_auth)\n\n    print(pd.DataFrame(al_objecttype_res.response))\n\n    # use to update `ActivityLog_ObjectType` enum\n    # [ f\"{objecttype.get('translation').upper().replace(' ', '_')} = '{objecttype.get('type')}'\" for objecttype in  al_objecttype_res.response]\n\nexcept Exception as e:\n    print(e)\n\n                  type         translation\n0         ACCESS_TOKEN        Access token\n1              ACCOUNT             Account\n2         ACTIVITY_LOG        Activity log\n3                ALERT               Alert\n4                  APP                 App\n..                 ...                 ...\n56                VIEW                View\n57        VIRTUAL_USER        Virtual user\n58     Workbench_AGENT     Workbench agent\n59       Workbench_JOB       Workbench job\n60  Workbench_SCHEDULE  Workbench schedule\n\n[61 rows x 2 columns]\n\n\n\nsource\n\n\n\nsearch_activity_log\n\n search_activity_log (auth:domolibrary.client.DomoAuth.DomoAuth,\n                      start_time:int, end_time:int, maximum:int,\n                      object_type:str=None,\n                      session:aiohttp.client.ClientSession=None,\n                      debug_api:bool=False, debug_loop:bool=False)\n\nloops over activity log api to retrieve audit logs\n\nimport os\nimport pandas as pd\nimport datetime as dt\n\nimport domolibrary.utils.convert as convert\n\nend_datetime = dt.datetime.today()\nstart_datetime = end_datetime - dt.timedelta(days=100)\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\npage_res = await search_activity_log(\n    object_type= 'PAGE',\n    start_time=convert.convert_datetime_to_epoch_millisecond(start_datetime),\n    end_time=convert.convert_datetime_to_epoch_millisecond(end_datetime),\n    auth=token_auth,\n    maximum=16,\n    debug_loop=False,\n)\n\npd.DataFrame(page_res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      objectId\n      objectName\n    \n  \n  \n    \n      0\n      -100000\n      Overview\n    \n    \n      1\n      -100001\n      Alerts\n    \n    \n      2\n      -100002\n      Shared\n    \n    \n      3\n      -100003\n      Favorites\n    \n    \n      4\n      -100012\n      CEO\n    \n  \n\n\n\n\n\nsample implementation of search_activity_log\n\nimport os\nimport pandas as pd\nimport datetime as dt\n\nimport domolibrary.utils.convert as convert\n\nend_datetime = dt.datetime.today()\nstart_datetime = end_datetime - dt.timedelta(days=100)\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\nactivity_log_res = await search_activity_log(\n    object_type= 'ACTIVITY_LOG',\n    start_time=convert.convert_datetime_to_epoch_millisecond(start_datetime),\n    end_time=convert.convert_datetime_to_epoch_millisecond(end_datetime),\n    auth=token_auth,\n    maximum=10,\n    debug_loop=False,\n    debug_api=False,\n)\n\npd.DataFrame(activity_log_res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      userName\n      userId\n      userType\n      actorName\n      actorId\n      actionType\n      objectName\n      objectId\n      objectType\n      additionalComment\n      time\n      eventText\n      clientId\n    \n  \n  \n    \n      0\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      domo_kbs\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      DATA_SOURCE\n      Jae Wilson updated DataSet domo_kbs.\n      1673394855540\n      Updated DataSet\n      None\n    \n    \n      1\n      test@test.com\n      test@test.com\n      USER\n      \n      0\n      FAILED_LOGIN\n      \n      \n      \n      test@test.com failed logging in. Logged in fro...\n      1673394855316\n      Failed login\n      None\n    \n    \n      2\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson logged in. Logged in from IP addres...\n      1673394855028\n      Logged in\n      None\n    \n    \n      3\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson logged in. Logged in from IP addres...\n      1673394854694\n      Logged in\n      None\n    \n    \n      4\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson logged in. Logged in from IP addres...\n      1673394853720\n      Logged in\n      None"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "domolibrary: a powerful pydomo alternative",
    "section": "",
    "text": "domolibrary is a Python package that provides a OOP (class-based) and a functional approach to interacting with Domo’s API framework.\nAll accessed APIs are documented under DataCrew’s Domo Documentation page.\nThis library was created by DataCrew contributor Jae Wilson."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "domolibrary: a powerful pydomo alternative",
    "section": "Install",
    "text": "Install\nThe DataCrew team is hard at work expanding the list of available classes and routes. We have a ton of work completed, it’s just a matter of migrating and documenting the code into this library.\npip install domo_library"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "domolibrary: a powerful pydomo alternative",
    "section": "How to use",
    "text": "How to use\n\nAuthentication\nFor each task, consider the appropriate DomoAuth mechanism. In most cases DomoFullAuth or DomoTokenAuth will be appropriate as this library predominately accesses private APIs.\nAny Public routes or methods will be labeled appropriately in which case you should use DomoDeveloperAuth. Public routes are APIs enumerated and documented under Developer.Domo.com.\nTypically each project will begin with configuring an auth object. If you are accessing multiple Domo instances, you’ll probably need multiple auth objects.\n\n# configure an auth method\nimport os\nimport domolibrary.client.DomoAuth as dmda\n\ntoken_auth = dmda.DomoTokenAuth( domo_instance = 'domo-dojoo', domo_access_token = os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\n\n\nOption 1: class based programming\nIn this project domo entities, DomoActivityLog, DomoDataset are all prefixed ‘Domo’ and can be found in the classes folder. Each class method will call one or more routes. Each route will interact with one and only one API.\nAlthough most methods will be standard methods that will be called after creating an instance of the class, some methods will be classmethods which return an instance of the class.\nIn the example below, DomoDataset.get_from_id is a classmethod.\nNote: DomoLibrary uses the asynchronous aiohttp requests library to offer users the ability to write concurrently executing code.\n\nimport domolibrary.classes.DomoDataset as dmds\n\n# this is a class method\ndomo_ds = await dmds.DomoDataset.get_from_id(auth = token_auth, dataset_id = os.environ['DOJO_DATASET_ID'])\ndomo_ds\n\nDomoDataset(id='04c1574e-c8be-4721-9846-c6ffa491144b', display_type='domo-jupyterdata', data_provider_type='domo-jupyterdata', name='domo_kbs', description=None, row_count=1185, column_count=7, stream_id=825, owner=DictDot(id='1893952720', name='Jae Wilson', type='USER', group=False), formula=DictDot(), schema=DomoDataset_Schema(dataset=..., columns=[]))\n\n\nOnce instantiated, you can call methods to interact with that object. You typically won’t have to pass auth creds again because they are saved to the object.\nIn the example below we are retrieving the DomoDataset_Schema which consists of subclass DomoDataset_Schema_Column using the DomoDataset_Schema.get method.\nWe take the approach of where possible converting dictionaries from Domo APIs into classes because it provides greater predictability when users are creating integrations between platforms (ex. Domo to Trello).\n\nawait domo_ds.schema.get()\n\n[DomoDataset_Schema_Column(name='objectID', id='objectID', type='STRING'),\n DomoDataset_Schema_Column(name='url', id='url', type='STRING'),\n DomoDataset_Schema_Column(name='Title', id='Title', type='STRING'),\n DomoDataset_Schema_Column(name='article', id='article', type='STRING'),\n DomoDataset_Schema_Column(name='views', id='views', type='LONG'),\n DomoDataset_Schema_Column(name='created_dt', id='created_dt', type='DATETIME'),\n DomoDataset_Schema_Column(name='published_dt', id='published_dt', type='DATETIME')]\n\n\nTypically all information about an entity is saved in the object\n\ndomo_ds.__dict__\n\n{'auth': DomoTokenAuth(domo_instance='domo-dojoo', token_name='token_auth', url_manual_login='https://domo-dojoo.domo.com/auth/index?domoManualLogin=true'),\n 'id': '04c1574e-c8be-4721-9846-c6ffa491144b',\n 'display_type': 'domo-jupyterdata',\n 'data_provider_type': 'domo-jupyterdata',\n 'name': 'domo_kbs',\n 'description': None,\n 'row_count': 1185,\n 'column_count': 7,\n 'stream_id': 825,\n 'owner': namespace(id='1893952720',\n           name='Jae Wilson',\n           type='USER',\n           group=False),\n 'formula': namespace(),\n 'schema': DomoDataset_Schema(dataset=DomoDataset(id='04c1574e-c8be-4721-9846-c6ffa491144b', display_type='domo-jupyterdata', data_provider_type='domo-jupyterdata', name='domo_kbs', description=None, row_count=1185, column_count=7, stream_id=825, owner=DictDot(id='1893952720', name='Jae Wilson', type='USER', group=False), formula=DictDot(), schema=...), columns=[DomoDataset_Schema_Column(name='objectID', id='objectID', type='STRING'), DomoDataset_Schema_Column(name='url', id='url', type='STRING'), DomoDataset_Schema_Column(name='Title', id='Title', type='STRING'), DomoDataset_Schema_Column(name='article', id='article', type='STRING'), DomoDataset_Schema_Column(name='views', id='views', type='LONG'), DomoDataset_Schema_Column(name='created_dt', id='created_dt', type='DATETIME'), DomoDataset_Schema_Column(name='published_dt', id='published_dt', type='DATETIME')])}\n\n\n\n\nOption 2 functional programming\nAlthough classes add a pretty wrapper for interacting with Domo APIs, users can opt to interact directly with APIs by way of routes.\nAll route functions will exclusively call one API and will always return a ResponseGetData object OR raise an Exception if appropriate.\nFor example we can implement similar functionality as the Option 1 example by calling the get_dataset_by_id function.\n\nimport domolibrary.routes.dataset as dataset_routes\n\nds_res = await dataset_routes.get_dataset_by_id( auth = token_auth, dataset_id = os.environ['DOJO_DATASET_ID'])\nds_res\n\nResponseGetData(status=200, response={'id': '04c1574e-c8be-4721-9846-c6ffa491144b', 'displayType': 'domo-jupyterdata', 'dataProviderType': 'domo-jupyterdata', 'type': 'Jupyter', 'name': 'domo_kbs', 'owner': {'id': '1893952720', 'name': 'Jae Wilson', 'type': 'USER', 'group': False}, 'status': 'SUCCESS', 'created': 1668379680000, 'lastTouched': 1668385822000, 'lastUpdated': 1668385822045, 'rowCount': 1185, 'columnCount': 7, 'cardInfo': {'cardCount': 0, 'cardViewCount': 0}, 'properties': {'formulas': {'formulas': {}}}, 'state': 'SUCCESS', 'validConfiguration': True, 'validAccount': True, 'streamId': 825, 'transportType': 'API', 'adc': False, 'adcExternal': False, 'cloudId': 'domo', 'cloudName': 'Domo', 'permissions': 'READ_WRITE_DELETE_SHARE_ADMIN', 'hidden': False, 'tags': '[\"developer_documentation\",\"Jan-11-2023 12:50\",\"hackercore\"]', 'scheduleActive': True, 'cryoStatus': 'ADRENALINE'}, is_success=True)\n\n\nResponseGetData will always include a boolean is_success, the API status, and raw API response.\nTypically the route methods will not alter the response unless the API does not include a descriptive response (ex, routes.dataset.set_dataset_tags does not return a response so we artificially alter the response in the function.)\n\n[(prop, type(getattr(ds_res , prop))) for prop in dir(ds_res) if not prop.startswith('_')]\n\n[('auth', domolibrary.client.DomoAuth.DomoTokenAuth),\n ('is_success', bool),\n ('response', dict),\n ('set_response', method),\n ('status', int)]\n\n\n\nds_res.response\n\n{'id': '04c1574e-c8be-4721-9846-c6ffa491144b',\n 'displayType': 'domo-jupyterdata',\n 'dataProviderType': 'domo-jupyterdata',\n 'type': 'Jupyter',\n 'name': 'domo_kbs',\n 'owner': {'id': '1893952720',\n  'name': 'Jae Wilson',\n  'type': 'USER',\n  'group': False},\n 'status': 'SUCCESS',\n 'created': 1668379680000,\n 'lastTouched': 1668385822000,\n 'lastUpdated': 1668385822045,\n 'rowCount': 1185,\n 'columnCount': 7,\n 'cardInfo': {'cardCount': 0, 'cardViewCount': 0},\n 'properties': {'formulas': {'formulas': {}}},\n 'state': 'SUCCESS',\n 'validConfiguration': True,\n 'validAccount': True,\n 'streamId': 825,\n 'transportType': 'API',\n 'adc': False,\n 'adcExternal': False,\n 'cloudId': 'domo',\n 'cloudName': 'Domo',\n 'permissions': 'READ_WRITE_DELETE_SHARE_ADMIN',\n 'hidden': False,\n 'tags': '[\"developer_documentation\",\"Jan-11-2023 12:50\",\"hackercore\"]',\n 'scheduleActive': True,\n 'cryoStatus': 'ADRENALINE'}\n\n\n\n\nAccess Paginated APIs using the Looper\nA hidden advantage of using the DomoLibrary is that paginated API requests are baked into the route’s definition.\nConsider query_dataset_private from the routes.dataset.\nInside this function we are using looper from client.get_data to paginate over the API response."
  },
  {
    "objectID": "domoauth.html",
    "href": "domoauth.html",
    "title": "DomoAuth",
    "section": "",
    "text": "Stand alone functions for users who prefer a functional programming approach\n\n\n\nsource\n\n\n\n get_full_auth (domo_instance:str, domo_username:str, domo_password:str,\n                session:Optional[aiohttp.client.ClientSession]=None)\n\nuses username and password authentication to retrieve a full_auth access token\n\n\n\nimport os\n\nres = await get_full_auth(\n    domo_instance=\"domo-dojo\",\n    domo_username=\"test@test.com\",\n    domo_password=\"fake password\",\n)\nres\n\nResponseGetData(status=200, response={'success': False, 'reason': 'INVALID_CREDENTIALS'}, is_success=True, auth=None)\n\n\n\nres = await get_full_auth(domo_instance=\"test\",\n                          domo_username=\"fake@test.com\", \n                          domo_password=\"fake password\")\nres\n\nResponseGetData(status=403, response='Forbidden', is_success=False, auth=None)\n\n\nThe 403 response is expected because test.domo.com presumeably does not exist or access if forbidden.\n\n\n\n\n\n\nsource\n\n\n\n get_developer_auth (domo_client_id:str, domo_client_secret:str,\n                     session:Optional[aiohttp.client.ClientSession]=None)\n\nonly use for authenticating against apis documented under developer.domo.com\n\n\nThe 401 response is expected because we are using invalid credentials\n\nawait get_developer_auth(domo_client_id=\"test_id\",\n                         domo_client_secret=\"test_secret\"\n                         )\n\nResponseGetData(status=401, response='Unauthorized', is_success=False, auth=None)\n\n\n\n\n\n\n\nThis access_token based authentication assumes the user has been provided a valid access token from Domo > Admin > Authentication > Access Token so authentication routes are actually not required.\nPer the Domo JavaCLI implementation, users can test the validity of the access_token agains the ‘me’ API\n!! Note about the Me API !! It appears that access_token authentication will direct the\n\nsource\n\n\n\n test_access_token (domo_access_token:str, domo_instance:str,\n                    session:Optional[aiohttp.client.ClientSession]=None)\n\nwill attempt to validate against the ‘me’ API. This is the same authentication test the Domo Java CLI uses.\n\n\n\nimport os\n\nawait test_access_token(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN']\n)\n\nResponseGetData(status=200, response={'id': 1893952720, 'invitorUserId': 587894148, 'displayName': 'Jae Wilson', 'userName': 'jae@onyxreporting.com', 'emailAddress': 'jae@onyxreporting.com', 'avatarKey': 'c605f478-0cd2-4451-9fd4-d82090b71e66', 'accepted': True, 'userType': 'USER', 'modified': 1651692505000, 'created': 1588960518, 'role': 'Admin', 'rights': 63, 'active': True, 'pending': False, 'systemUser': False, 'anonymous': False}, is_success=True, auth=None)"
  },
  {
    "objectID": "domoauth.html#domoauth-error-classes",
    "href": "domoauth.html#domoauth-error-classes",
    "title": "DomoAuth",
    "section": "DomoAuth Error Classes",
    "text": "DomoAuth Error Classes\n\nsource\n\nInvalidInstanceError\n\n InvalidInstanceError (status:Optional[int]=None, message='invalid\n                       instance', domo_instance:Optional[str]=None)\n\nreturn if invalid domo_instance sent to API\n\nsource\n\n\nInvalidCredentialsError\n\n InvalidCredentialsError (status:Optional[int]=None, message='invalid\n                          credentials', domo_instance:Optional[str]=None)\n\nreturn invalid credentials sent to API\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nstatus\nOptional\nNone\nAPI request status\n\n\nmessage\nstr\ninvalid credentials\n\n\n\ndomo_instance\nOptional\nNone"
  },
  {
    "objectID": "domoauth.html#domofullauth",
    "href": "domoauth.html#domofullauth",
    "title": "DomoAuth",
    "section": "DomoFullAuth",
    "text": "DomoFullAuth\n\nsource\n\nDomoFullAuth\n\n DomoFullAuth (domo_instance:str, domo_username:str, domo_password:str,\n               token:Optional[str]=None, token_name:Optional[str]=None,\n               user_id:Optional[str]=None, auth_header:dict=<factory>,\n               url_manual_login:Optional[str]=None)\n\nuse for full authentication token\n\nsample implementations of DomoFullAuth\n\ntry:\n    full_auth = DomoFullAuth(domo_instance=\"domo-dojo\",\n                             domo_username=\"test12@domo.com\",\n                             domo_password=\"test1234\")\n    res = await full_auth.get_auth_token()\n\nexcept InvalidCredentialsError as e:\n    print(e)\n\nStatus 200 - INVALID_CREDENTIALS at domo-dojo\n\n\n\ntry:\n    full_auth = DomoFullAuth(domo_instance=\"test\",\n                             domo_username=\"test12@domo.com\",\n                             domo_password=\"test1234\")\n    await full_auth.get_auth_token()\nexcept InvalidInstanceError as e:\n    print(e)\n\nStatus 403 - INVALID INSTANCE at test"
  },
  {
    "objectID": "domoauth.html#domotokenauth",
    "href": "domoauth.html#domotokenauth",
    "title": "DomoAuth",
    "section": "DomoTokenAuth",
    "text": "DomoTokenAuth\n\nsource\n\nDomoTokenAuth\n\n DomoTokenAuth (domo_instance:str, domo_access_token:str,\n                token:Optional[str]=None, token_name:Optional[str]=None,\n                user_id:Optional[str]=None, auth_header:dict=<factory>,\n                url_manual_login:Optional[str]=None)\n\nuse for access_token authentication. Tokens are generated in domo > admin > access token Necessary in cases where direct sign on is not permitted\n\nSample implementation of DomoTokenAuth\n\ntry:\n    domo_auth = DomoTokenAuth(domo_instance=\"domo-dojo\",\n                              domo_access_token='fake password')\n    token = await domo_auth.get_auth_token()\n    print(domo_auth)\n\nexcept InvalidCredentialsError as e:\n    print(e)\n\nStatus 401 - Unauthorized at domo-dojo"
  },
  {
    "objectID": "domoauth.html#domodeveloperauth",
    "href": "domoauth.html#domodeveloperauth",
    "title": "DomoAuth",
    "section": "DomoDeveloperAuth",
    "text": "DomoDeveloperAuth\n\nsource\n\nDomoDeveloperAuth\n\n DomoDeveloperAuth (domo_client_id:str, domo_client_secret:str)\n\nuse for full authentication token\n\nSample implementations of DomoDeveloperAuth\n\ndomo_client_id = \"test_client\"\ndomo_client_secret = \"test_secret\"\n\ntry:\n    domo_auth = DomoDeveloperAuth(domo_client_id, domo_client_secret)\n    await domo_auth.get_auth_token()\nexcept InvalidCredentialsError as e:\n    print(e)\n\nStatus 401 - Unauthorized"
  },
  {
    "objectID": "utils/utils.convert.html",
    "href": "utils/utils.convert.html",
    "title": "Conversion utility functions",
    "section": "",
    "text": "source\n\nconvert_epoch_millisecond_to_datetime\n\n convert_epoch_millisecond_to_datetime (epoch:int)\n\nconvert Epoch time with miliseconds to Date time\n\nsource\n\n\nconvert_datetime_to_epoch_millisecond\n\n convert_datetime_to_epoch_millisecond (datetime:datetime.datetime)\n\nconvert DateTime to Epoch time with Miliseconds\n\nimport time\nimport datetime as dt \n\ncur_time = int(time.time()*1000)\n\ncur_datetime =  convert_epoch_millisecond_to_datetime(cur_time)\nprint(cur_datetime)\n\ntest_time = convert_datetime_to_epoch_millisecond(cur_datetime)\nprint(test_time)\n\nfctest.test_eq(test_time, cur_time)\n\n2023-01-07 00:51:35.572000\n1673052695572\n\n\n\nsource\n\n\nconvert_snake_to_pascal\n\n convert_snake_to_pascal (str)\n\nconverts ‘snake_case_str’ to ‘snakeCaseStr’\n\nconvert_str = 'test_snake_case'\n\nconvert_snake_to_pascal(convert_str)\n\n'testSnakeCase'"
  },
  {
    "objectID": "utils/dictdot.html",
    "href": "utils/dictdot.html",
    "title": "DictDot",
    "section": "",
    "text": "source\n\nDictDot\n\n DictDot (dictionary:dict, **kwargs)\n\na utility class that converts json into an object that supports data retrieval with dot notation\n\n\n\n\nType\nDetails\n\n\n\n\ndictionary\ndict\ndictionary to convert\n\n\nkwargs\n\n\n\n\n\n\nsample implementation of DictDot\n\nfoo = { \"name\": \"my object\", \"description\" : \"please convert me\", \"type\": \"a good old fashioned dictionary\"}\n\ndd = DictDot(foo)\n\nprint(dd)\n\ndd.type\n\nDictDot(name='my object', description='please convert me', type='a good old fashioned dictionary')\n\n\n'a good old fashioned dictionary'"
  },
  {
    "objectID": "routes/activity_log.html#activity-log-routes",
    "href": "routes/activity_log.html#activity-log-routes",
    "title": "Activity Log",
    "section": "Activity Log Routes",
    "text": "Activity Log Routes\n\nsource\n\nsearch_activity_log\n\n search_activity_log (domo_auth:domolibrary.DomoAuth.DomoAuth,\n                      start_time:int, end_time:int, maximum:int, object_ty\n                      pe:Optional[__main__.ActivityLog_ObjectType]=None,\n                      session:aiohttp.client.ClientSession=None,\n                      debug_api:bool=False, debug_loop:bool=False)\n\nloops over activity log api to retrieve audit logs\n\nimport os\nimport pandas as pd\nimport datetime as dt\n\nimport domolibrary.utils.convert as convert\n\nend_datetime = dt.datetime.today()\nstart_datetime = end_datetime - dt.timedelta(days=100)\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\npage_res = await search_activity_log(\n    object_type=ActivityLog_ObjectType.PAGE,\n    start_time=convert.convert_datetime_to_epoch_millisecond(start_datetime),\n    end_time=convert.convert_datetime_to_epoch_millisecond(end_datetime),\n    domo_auth=token_auth,\n    maximum=16,\n    debug_loop=False,\n)\n\npd.DataFrame(page_res[10:15])\n\n\n\n\n\n  \n    \n      \n      objectId\n      objectName\n    \n  \n  \n    \n      0\n      1040607753\n      Campaigns\n    \n    \n      1\n      1050465610\n      MetaData Table Info and QA\n    \n    \n      2\n      1055094721\n      Scott's CRM APP\n    \n    \n      3\n      1067418640\n      Form Builder\n    \n    \n      4\n      1080655546\n      Cloud Costs\n    \n  \n\n\n\n\n\nsample implementation of search_activity_log\n\nimport os\nimport pandas as pd\nimport datetime as dt\n\nimport domolibrary.utils.convert as convert\n\nend_datetime = dt.datetime.today()\nstart_datetime = end_datetime - dt.timedelta(days=100)\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\nactivity_log_res = await search_activity_log(\n    object_type=ActivityLog_ObjectType.ACTIVITY_LOG,\n    start_time=convert.convert_datetime_to_epoch_millisecond(start_datetime),\n    end_time=convert.convert_datetime_to_epoch_millisecond(end_datetime),\n    domo_auth=token_auth,\n    maximum=100,\n    debug_loop=False,\n    debug_api=False,\n)\n\npd.DataFrame(activity_log_res[95:100])\n\n\n\n\n\n  \n    \n      \n      userName\n      userId\n      userType\n      actorName\n      actorId\n      actionType\n      objectName\n      objectId\n      objectType\n      additionalComment\n      time\n      eventText\n      clientId\n    \n  \n  \n    \n      0\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson logged in. Logged in from IP addres...\n      1673044017279\n      Logged in\n      None\n    \n    \n      1\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson logged in. Logged in from IP addres...\n      1673044016676\n      Logged in\n      None\n    \n    \n      2\n      test@test.com\n      test@test.com\n      USER\n      \n      0\n      FAILED_LOGIN\n      \n      \n      \n      test@test.com failed logging in. Logged in fro...\n      1673044016554\n      Failed login\n      None\n    \n    \n      3\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson logged in. Logged in from IP addres...\n      1673043933005\n      Logged in\n      None\n    \n    \n      4\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson logged in. Logged in from IP addres...\n      1673043931236\n      Logged in\n      None"
  },
  {
    "objectID": "classes/domoactivitylog.html",
    "href": "classes/domoactivitylog.html",
    "title": "Activity Log",
    "section": "",
    "text": "class ActivityLog_ObjectType(Enum):\n    \"\"\"enumerates valid object types to pass to activity log api\"\"\"\n\n    ACCESS_TOKEN = \"ACCESS_TOKEN\"\n    ACCOUNT = \"ACCOUNT\"\n    ACTIVITY_LOG = \"ACTIVITY_LOG\"\n    ALERT = \"ALERT\"\n    APP = \"APP\"\n    APPDB_COLLECTION = \"MAGNUM_COLLECTION\"\n    APPDB_DATASTORE = \"MAGNUM_DATASTORE\"\n    AUTHORITY = \"AUTHORITY\"\n    BEAST_MODE_FORMULA = \"BEAST_MODE_FORMULA\"\n    BUZZ_CHANNEL = \"CHANNEL\"\n    BUZZ_GROUP_CHAT = \"GROUP_CHAT\"\n    BUZZ_THREAD = \"HUDDLE\"\n    CARD = \"CARD\"\n    CHART_COLOR_PALETTE = \"CHART_COLOR_PALETTE\"\n    COLLECTION = \"COLLECTION\"\n    CUSTOMER = \"CUSTOMER\"\n    CUSTOMER_STATE = \"CUSTOMER_STATE\"\n    CUSTOMER_TIER = \"CUSTOMER_TIER\"\n    DATA_SCIENCE_NOTEBOOK = \"DATA_SCIENCE_NOTEBOOK\"\n    DATAFLOW = \"DATAFLOW_TYPE\"\n    DATASET = \"DATA_SOURCE\"\n    DATASOURCE = \"DATASOURCE\"\n    DEPLOYMENT = \"DEPLOYMENT\"\n    DRILL_VIEW = \"DRILL_VIEW\"\n    EASY_INVITE_LINK = \"EASY_INVITE_LINK\"\n    ENABLED = \"ENABLED\"\n    FILE = \"FILE\"\n    FILE_VERSION = \"FILE_REVISION\"\n    GROUP = \"GROUP\"\n    LICENSE_PAGE = \"LICENSE_PAGE\"\n    LOGIN_SETTINGS = \"LOGIN_SETTINGS\"\n    NAME = \"NAME\"\n    PDP_FILTER = \"ADC_FILTER\"\n    PDP_POLICY = \"ADC_POLICY\"\n    PAGE = \"PAGE\"\n    PAGE_ANALYZER = \"PAGE_ANALYZER\"\n    PAGE_COLLECTION = \"PAGE_COLLECTION\"\n    PROJECT = \"PROJECT\"\n    PROJECT_LIST = \"PROJECT_LIST\"\n    PROJECT_TASK = \"PROJECT_TASK\"\n    PROJECT_TASK_ATTACHMENT = \"PROJECT_TASK_ATTACHMENT\"\n    PROJECT_TASK_OWNER = \"PROJECT_TASK_OWNER\"\n    PROXIER_EMAIL = \"PROXIER_EMAIL\"\n    PUBLIC_EMBED_URL = \"PUBLIC_URL\"\n    PUBLICATION = \"PUBLICATION\"\n    REPOSITORY = \"REPOSITORY\"\n    REPOSITORY_AUTHORIZATION = \"REPOSITORY_AUTHORIZATION\"\n    ROLE = \"ROLE\"\n    SEGMENT = \"SEGMENT\"\n    SSO_PAGE = \"SSO_PAGE\"\n    SUBSCRIBER = \"PROXY_USER\"\n    USER = \"USER\"\n    USER_STATE = \"USER_STATE\"\n    VARIABLE = \"VARIABLE\"\n    VARIABLE_CONTROL = \"VARIABLE_CONTROL\"\n    NOTEBOOK_VIEW = \"CONTAINER_VIEW\"\n    VIEW = \"VIEW\"\n    VIRTUAL_USER = \"VIRTUAL_USER\"\n    WORKBENCH_AGENT = \"Workbench_AGENT\"\n    WORKBENCH_JOB = \"Workbench_JOB\"\n    WORKBENCH_SCHEDULE = \"Workbench_SCHEDULE\"\n\n\nsource\n\nActivityLog_ObjectType\n\n ActivityLog_ObjectType (value, names=None, module=None, qualname=None,\n                         type=None, start=1)\n\nenumerates valid object types to pass to activity log api\nTo get an updated list of objectTypes run the get_activity_log_object_types function.\nNote: in the ActivityLog_ObjectType enum, some of the entries have been renamed for clarity.\n\nsource\n\n\nDomoActivityLog\n\n DomoActivityLog ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\nimport os\nimport pandas as pd\nimport datetime as dt\n\nend_datetime = dt.datetime.today()\nstart_datetime = end_datetime - dt.timedelta(days=100)\n\ntoken_auth = dmda.DomoTokenAuth(domo_instance='domo-dojo',\n                                    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"])\n\nal_res = await DomoActivityLog.get_activity_log(\n    auth = token_auth,\n    start_time = start_datetime,\n    end_time = end_datetime,\n    object_type = ActivityLog_ObjectType.ACTIVITY_LOG,\n    maximum =5)\n\npd.DataFrame(al_res)\n\n\n\n\n\n  \n    \n      \n      userName\n      userId\n      userType\n      actorName\n      actorId\n      actionType\n      objectName\n      objectId\n      objectType\n      additionalComment\n      time\n      eventText\n      clientId\n      time_dt\n      date\n    \n  \n  \n    \n      0\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      domo_kbs\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      DATA_SOURCE\n      Jae Wilson updated DataSet domo_kbs.\n      1673394850374\n      Updated DataSet\n      None\n      2023-01-10 23:54:10.374\n      2023-01-10\n    \n    \n      1\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      domo_kbs\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      DATA_SOURCE\n      Jae Wilson updated DataSet domo_kbs.\n      1673394847991\n      Updated DataSet\n      None\n      2023-01-10 23:54:07.991\n      2023-01-10\n    \n    \n      2\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson logged in. Logged in from IP addres...\n      1673394846108\n      Logged in\n      None\n      2023-01-10 23:54:06.108\n      2023-01-10\n    \n    \n      3\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      LOGGEDIN\n      \n      \n      \n      Jae Wilson logged in. Logged in from IP addres...\n      1673394845785\n      Logged in\n      None\n      2023-01-10 23:54:05.785\n      2023-01-10\n    \n    \n      4\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      domo_kbs\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      DATA_SOURCE\n      Jae Wilson updated DataSet domo_kbs.\n      1673394845685\n      Updated DataSet\n      None\n      2023-01-10 23:54:05.685\n      2023-01-10"
  },
  {
    "objectID": "routes/dataset.html",
    "href": "routes/dataset.html",
    "title": "Dataset Routes",
    "section": "",
    "text": "source\n\n\n\n DatasetNotFoundError (dataset_id, domo_instance)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\n\n\n query_dataset_private (auth:domolibrary.client.DomoAuth.DomoAuth,\n                        dataset_id:str, sql:str, session:Optional[aiohttp.\n                        client.ClientSession]=None,\n                        loop_until_end:bool=False, limit=100, skip=0,\n                        maximum=100, debug_api:bool=False,\n                        debug_loop:bool=False)\n\nexecute SQL queries against private APIs, requires DomoFullAuth or DomoTokenAuth\n\nsource\n\n\n\n\n query_dataset_public\n                       (dev_auth:domolibrary.client.DomoAuth.DomoDeveloper\n                       Auth, dataset_id:str, sql:str,\n                       session:aiohttp.client.ClientSession,\n                       debug_api:bool=False)\n\nquery for hitting public apis, requires client_id and secret authentication\n\nsource\n\n\n\n\n QueryRequestError (dataset_id, domo_instance, sql)\n\nCommon base class for all non-exit exceptions.\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nsql = f\"SELECT * FROM TABLE\"\n\nds_res = await query_dataset_private(dataset_id=os.environ['DOJO_DATASET_ID'],\n                                     auth=token_auth,\n                                     sql=sql,\n                                     skip=42,\n                                     maximum=5,\n                                     loop_until_end=False)\npd.DataFrame(ds_res.response)\n\n\n\n\n\n  \n    \n      \n      objectID\n      url\n      Title\n      article\n      views\n      created_dt\n      published_dt\n    \n  \n  \n    \n      0\n      000004790\n      https://domo-support.domo.com/s/article/360046...\n      Starting, Stopping, and Restarting the Workben...\n      Important:  Support for Workbench 4 ended on ...\n      39\n      2022-10-24T22:30:00\n      2022-10-24T22:41:00\n    \n    \n      1\n      000004796\n      https://domo-support.domo.com/s/article/360047...\n      Understanding the Workbench 4 User Interface\n      Important:  Support for Workbench 4 ended on ...\n      56\n      2022-10-24T22:30:00\n      2022-10-24T22:40:00\n    \n    \n      2\n      000004773\n      https://domo-support.domo.com/s/article/360046...\n      Using the External Process File Provider in Wo...\n      Important:  Support for Workbench 4 ended on ...\n      20\n      2022-10-24T22:30:00\n      2022-10-24T22:41:00\n    \n    \n      3\n      000004798\n      https://domo-support.domo.com/s/article/360046...\n      Workbench 4 FAQs\n      Important:  Support for Workbench 4 ended on ...\n      48\n      2022-10-24T22:30:00\n      2022-10-24T22:40:00\n    \n    \n      4\n      000004800\n      https://domo-support.domo.com/s/article/360047...\n      Workbench 4 Overview\n      Important:  Support for Workbench 4 ended on ...\n      40\n      2022-10-24T22:30:00\n      2022-10-24T22:41:00"
  },
  {
    "objectID": "routes/dataset.html#query-datasets",
    "href": "routes/dataset.html#query-datasets",
    "title": "Dataset Routes",
    "section": "Query Datasets",
    "text": "Query Datasets\n\nsource\n\nquery_dataset_public\n\n query_dataset_public (dev_auth:domolibrary.DomoAuth.DomoDeveloperAuth,\n                       dataset_id:str, sql:str,\n                       session:aiohttp.client.ClientSession,\n                       debug_api:bool=False)\n\nquery for hitting public apis, requires client_id and secret authentication\n\nsource\n\n\nquery_dataset_private\n\n query_dataset_private (auth:domolibrary.DomoAuth.DomoAuth,\n                        dataset_id:str, sql:str, session:Optional[aiohttp.\n                        client.ClientSession]=None,\n                        loop_until_end:bool=False, limit=100, skip=0,\n                        maximum=100, debug_api:bool=False,\n                        debug_loop:bool=False)\n\nexecute SQL queries against private APIs, requires DomoFullAuth or DomoTokenAuth\n\nsample implementation of query_dataset_private\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nsql = f\"SELECT * FROM TABLE\"\n\nds_res = await query_dataset_private(dataset_id=DATASET_ID, auth=token_auth,\n                                     sql=sql, \n                                     skip=42, \n                                     maximum=5,\n                                     loop_until_end=False)\npd.DataFrame(ds_res.response)\n\n\n\n\n\n  \n    \n      \n      objectID\n      url\n      Title\n      article\n      views\n      created_dt\n      published_dt\n    \n  \n  \n    \n      0\n      000004790\n      https://domo-support.domo.com/s/article/360046...\n      Starting, Stopping, and Restarting the Workben...\n      Important:  Support for Workbench 4 ended on ...\n      39\n      2022-10-24T22:30:00\n      2022-10-24T22:41:00\n    \n    \n      1\n      000004796\n      https://domo-support.domo.com/s/article/360047...\n      Understanding the Workbench 4 User Interface\n      Important:  Support for Workbench 4 ended on ...\n      56\n      2022-10-24T22:30:00\n      2022-10-24T22:40:00\n    \n    \n      2\n      000004773\n      https://domo-support.domo.com/s/article/360046...\n      Using the External Process File Provider in Wo...\n      Important:  Support for Workbench 4 ended on ...\n      20\n      2022-10-24T22:30:00\n      2022-10-24T22:41:00\n    \n    \n      3\n      000004798\n      https://domo-support.domo.com/s/article/360046...\n      Workbench 4 FAQs\n      Important:  Support for Workbench 4 ended on ...\n      48\n      2022-10-24T22:30:00\n      2022-10-24T22:40:00\n    \n    \n      4\n      000004800\n      https://domo-support.domo.com/s/article/360047...\n      Workbench 4 Overview\n      Important:  Support for Workbench 4 ended on ...\n      40\n      2022-10-24T22:30:00\n      2022-10-24T22:41:00"
  },
  {
    "objectID": "classes/domodataset.html",
    "href": "classes/domodataset.html",
    "title": "Dataset",
    "section": "",
    "text": "The DomoDataset_Schema class will be a subclass of DomoDataset. It will handle all of the methods for interacting with schemas.\n\nIn execution, the schema is separate from the data that gets uploaded from Vault to Adrenaline. The domo schema defines how the data is loaded into Vault.\nBe cognizant to match dataset uploads with schema definitions. If the schema and uploaded data types do not match, the dataset may be unable to index in Adrenaline (and therefore not update).\n\n\nsource\n\n\n\n DomoDataset_Schema (dataset:<built-infunctionany>=None,\n                     columns:List[__main__.DomoDataset_Schema_Column]=<fac\n                     tory>)\n\nclass for interacting with dataset schemas\n\nsource\n\n\n\n\n DomoDataset_Schema_Column (name:str, id:str, type:str)\n\n\nsource\n\n\n\n\n DatasetSchema_DatasetNotProvidedError ()\n\nreturn if DatasetSchema request does not have a dataset id\n\nsource\n\n\n\n\n DatasetSchema_AuthNotProvidedError (dataset_id)\n\nreturn if DatasetSchema request cannot access an auth object\n\nsource\n\n\n\n\n DomoDataset_Schema.get\n                         (auth:Optional[domolibrary.client.DomoAuth.DomoAu\n                         th]=None, dataset_id:str=None,\n                         debug_api:bool=False, return_raw_res:bool=False)\n\nmethod that retrieves schema for a dataset\n\n\nStandard implementation will be to access the DomoDataset_Schema class as the DomoDataset.schema property\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nds_schema = DomoDataset_Schema()\n\nawait ds_schema.get(auth=token_auth, dataset_id=os.environ[\"DOJO_DATASET_ID\"])\n\n[DomoDataset_Schema_Column(name='objectID', id='objectID', type='STRING'),\n DomoDataset_Schema_Column(name='url', id='url', type='STRING'),\n DomoDataset_Schema_Column(name='Title', id='Title', type='STRING'),\n DomoDataset_Schema_Column(name='article', id='article', type='STRING'),\n DomoDataset_Schema_Column(name='views', id='views', type='LONG'),\n DomoDataset_Schema_Column(name='created_dt', id='created_dt', type='DATETIME'),\n DomoDataset_Schema_Column(name='published_dt', id='published_dt', type='DATETIME')]\n\n\n\nsource\n\n\n\n\n\n DomoDataset_Tags (dataset:<built-infunctionany>=None,\n                   tag_ls:List[str]=<factory>)\n\nclass for interacting with dataset tags\n\nsource\n\n\n\n\n DatasetTags_SetTagsError (dataset_id, domo_instance)\n\nreturn if DatasetTags request is not successfull\n\nsource\n\n\n\n\n DatasetTags_AuthNotProvidedError (id)\n\nreturn if DatasetTags request cannot access an auth object\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nds_tag = DomoDataset_Tags()\nawait ds_tag.get(auth=token_auth, dataset_id=os.environ[\"DOJO_DATASET_ID\"])\n\n['Jan-11-2023 13:17', '2023', 'developer_documentation', 'hackercore']\n\n\n\nimport os\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ntoday = dt.datetime.now().strftime(\"%b-%d-%Y %H:%M\")\nds_tag = DomoDataset_Tags()\nawait ds_tag.set(\n    auth=token_auth,\n    dataset_id=os.environ[\"DOJO_DATASET_ID\"],\n    tag_ls=[\"developer_documentation\", \"hackercore\", today],\n)\n\n['developer_documentation', 'hackercore']\n\n\n\nsource\n\n\n\n\n DomoDataset_Tags.add (add_tag_ls:[<class'str'>], dataset_id:str=None,\n                       auth:Optional[domolibrary.client.DomoAuth.DomoAuth]\n                       =None, debug_api:bool=False, session:Optional[aioht\n                       tp.client.ClientSession]=None)\n\nappends tags to the list of existing dataset_tags\n\nimport os\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ntoday_year = dt.datetime.today().strftime(\"%Y\")\nds_tag = DomoDataset_Tags()\nawait ds_tag.add(\n    auth=token_auth, dataset_id=os.environ[\"DOJO_DATASET_ID\"], add_tag_ls=[today_year]\n)\n\n['2023', 'developer_documentation', 'hackercore']\n\n\n\nsource\n\n\n\n\n DomoDataset_Tags.remove (remove_tag_ls:[<class'str'>],\n                          dataset_id:str=None, auth:domolibrary.client.Dom\n                          oAuth.DomoFullAuth=None, debug_api:bool=False, s\n                          ession:Optional[aiohttp.client.ClientSession]=No\n                          ne)\n\nremoves tags from the existing list of dataset_tags\n\nimport os\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ntoday_year = dt.datetime.today().strftime(\"%Y\")\n\nds_tag = DomoDataset_Tags()\n\nawait ds_tag.remove(\n    auth=token_auth, dataset_id=os.environ[\"DOJO_DATASET_ID\"], remove_tag_ls=[ today_year])\n\n['developer_documentation', 'hackercore']"
  },
  {
    "objectID": "routes/tag.html",
    "href": "routes/tag.html",
    "title": "Tag Routes",
    "section": "",
    "text": "async def get_dataset_tags(auth: dmda.DomoFullAuth,\n                            tag_ls: [str],\n                            dataset_id: str,\n                            debug_api: bool = False,\n                            session: Optional[aiohttp.ClientSession] = None,\n                            ):\n\n    url = f\"https://{auth.domo_instance}.domo.com/api/data/ui/v3/datasources/{dataset_id}/tags\"\n\n    return await gd.get_data(\n        auth= auth,\n        url=url,\n        method='GET',\n        debug_api=debug_api,\n        body=tag_ls,\n        session=session\n    )\n\n\n\nset_dataset_tags\n\n set_dataset_tags (auth:domolibrary.DomoAuth.DomoFullAuth,\n                   tag_ls:[<class'str'>], dataset_id:str,\n                   debug_api:bool=False,\n                   session:Optional[aiohttp.client.ClientSession]=None)\n\n\nsample implementation of set_dataset_tags\n\nimport os \n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\n\n\n\n\nDataset_Tags\n\n Dataset_Tags (dataset:<built-infunctionany>, tag_ls:[<class'str'>]=None)"
  },
  {
    "objectID": "routes/dataset.html#dataset-properties",
    "href": "routes/dataset.html#dataset-properties",
    "title": "Dataset Routes",
    "section": "Dataset Properties",
    "text": "Dataset Properties\n\nsource\n\nget_dataset_by_id\n\n get_dataset_by_id (dataset_id:str,\n                    auth:Optional[domolibrary.client.DomoAuth.DomoAuth]=No\n                    ne, debug_api:bool=False,\n                    session:Optional[aiohttp.client.ClientSession]=None)\n\nretrieve dataset metadata\n\nimport os\nimport pandas as pd\n\ntry:\n    token_auth = dmda.DomoTokenAuth(\n        domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n    )\n\n    await get_dataset_by_id(dataset_id=123, auth=token_auth)\n\nexcept DatasetNotFoundError as e:\n    print(e)\n\ndataset - 123 not found in domo-dojo\n\n\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nds_res = await get_dataset_by_id(dataset_id=os.environ['DOJO_DATASET_ID'], auth=token_auth)\npd.DataFrame([ds_res.response])\n\n\n\n\n\n  \n    \n      \n      id\n      displayType\n      dataProviderType\n      type\n      name\n      owner\n      status\n      created\n      lastTouched\n      lastUpdated\n      rowCount\n      columnCount\n      cardInfo\n      properties\n      state\n      validConfiguration\n      validAccount\n      streamId\n      transportType\n      adc\n      adcExternal\n      cloudId\n      cloudName\n      permissions\n      hidden\n      tags\n      scheduleActive\n      cryoStatus\n    \n  \n  \n    \n      0\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      domo-jupyterdata\n      domo-jupyterdata\n      Jupyter\n      domo_kbs\n      {'id': '1893952720', 'name': 'Jae Wilson', 'ty...\n      SUCCESS\n      1668379680000\n      1668385822000\n      1668385822045\n      1185\n      7\n      {'cardCount': 0, 'cardViewCount': 0}\n      {'formulas': {'formulas': {}}}\n      SUCCESS\n      True\n      True\n      825\n      API\n      False\n      False\n      domo\n      Domo\n      READ_WRITE_DELETE_SHARE_ADMIN\n      False\n      [\"Jan-11-2023 13:17\",\"developer_documentation\"...\n      True\n      ADRENALINE\n    \n  \n\n\n\n\n\nsource\n\n\nget_schema\n\n get_schema (auth:domolibrary.client.DomoAuth.DomoAuth, dataset_id:str,\n             debug_api:bool=False)\n\nretrieve the schema for a dataset\n\nsample implementation of get_schema\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nds_res = await get_schema(dataset_id=os.environ['DOJO_DATASET_ID'], auth=token_auth)\npd.DataFrame(ds_res.response)\n\n\n\n\n\n  \n    \n      \n      name\n      tables\n      dataSourceId\n      url\n      queryEndpoint\n      progressEndpoint\n      indexEndpoint\n      deleteEndpoint\n      versionId\n    \n  \n  \n    \n      0\n      domo_kbs\n      {'columns': [{'name': 'objectID', 'id': 'objec...\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      /schemas/853832B128D75BCE\n      /query/mmmm-0012-0200/04c1574e-c8be-4721-9846-...\n      /index/mmmm-0012-0200/04c1574e-c8be-4721-9846-...\n      /index/mmmm-0012-0200/04c1574e-c8be-4721-9846-...\n      /delete/mmmm-0012-0200/04c1574e-c8be-4721-9846...\n      3\n    \n  \n\n\n\n\n\n# retrieve schema from response\npd.DataFrame(ds_res.response.get(\"tables\")[0].get(\"columns\"))\n\n\nsource\n\n\n\nset_dataset_tags\n\n set_dataset_tags (auth:domolibrary.client.DomoAuth.DomoFullAuth,\n                   tag_ls:[<class'str'>], dataset_id:str,\n                   debug_api:bool=False,\n                   session:Optional[aiohttp.client.ClientSession]=None)\n\nREPLACE tags on this dataset with a new list\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\ntag_ls = ['hackercore', 'developer_documentation']\n\nawait set_dataset_tags(auth=token_auth,\n                       tag_ls=tag_ls,\n                       dataset_id=os.environ['DOJO_DATASET_ID'])\n\nResponseGetData(status=200, response='Dataset 04c1574e-c8be-4721-9846-c6ffa491144b tags updated to [hackercore, developer_documentation]', is_success=True)"
  },
  {
    "objectID": "routes/dataset.html#upload-data",
    "href": "routes/dataset.html#upload-data",
    "title": "Dataset Routes",
    "section": "Upload Data",
    "text": "Upload Data\n\noverview\nIn the URL, parts refers to the multi-part API and is unrelated to the partitions concept. The multi-part API was designed to allow sending multiple streams of Data into a data_version simultaneously.\nIn stage 1, the values passed in the Body will be superseded by values in the COMMIT (stage 3), so best practices is to not populate values here.\nThe response includes an uploadId, which must be stored and passed to the URL of the subsequent upload request (stages 2 and 3).\n\n\nurl params\nThe dataTag parameter allows users to UPDATE or REPLACE a datatag (partition)\nNOTE: restateDataTag is largely deprecated // exists for backward compatibility\n\n\nbody params\nThe appendId parameter accepts “latest” or “None”\nlatest will APPEND the data version to the dataset\n\nsource\n\n\nUploadDataError\n\n UploadDataError (stage_num:int, dataset_id:str, domo_instance:str)\n\nraise if unable to upload data to Domo\n\nsource\n\n\nupload_dataset_stage_1\n\n upload_dataset_stage_1 (auth:domolibrary.client.DomoAuth.DomoAuth,\n                         dataset_id:str, partition_tag:str=None, session:O\n                         ptional[aiohttp.client.ClientSession]=None,\n                         debug_api:bool=False)\n\npreps dataset for upload by creating an upload_id (upload session key) pass to stage 2 as a parameter\n\nsource\n\n\nupload_dataset_stage_2_file\n\n upload_dataset_stage_2_file (auth:domolibrary.client.DomoAuth.DomoAuth,\n                              dataset_id:str, upload_id:str,\n                              data_file:Optional[_io.TextIOWrapper]=None, \n                              session:Optional[aiohttp.client.ClientSessio\n                              n]=None, part_id:str=2,\n                              debug_api:bool=False)\n\n\nsource\n\n\nupload_dataset_stage_2_df\n\n upload_dataset_stage_2_df (auth:domolibrary.client.DomoAuth.DomoAuth,\n                            dataset_id:str, upload_id:str,\n                            upload_df:pandas.core.frame.DataFrame, session\n                            :Optional[aiohttp.client.ClientSession]=None,\n                            part_id:str=2, debug_api:bool=False)\n\n\nsource\n\n\nupload_dataset_stage_3\n\n upload_dataset_stage_3 (auth:domolibrary.client.DomoAuth.DomoAuth,\n                         dataset_id:str, upload_id:str, session:Optional[a\n                         iohttp.client.ClientSession]=None,\n                         update_method:str='REPLACE',\n                         partition_tag:str=None, is_index:bool=False,\n                         debug_api:bool=False)\n\ncommit will close the upload session, upload_id. this request defines how the data will be loaded into Adrenaline, update_method has optional flag for indexing dataset.\n\nsource\n\n\nindex_dataset\n\n index_dataset (auth:domolibrary.client.DomoAuth.DomoAuth, dataset_id:str,\n                session:Optional[aiohttp.client.ClientSession]=None,\n                debug_api:bool=False)\n\nmanually index a dataset\n\nsource\n\n\nindex_status\n\n index_status (auth:domolibrary.client.DomoAuth.DomoAuth, dataset_id:str,\n               index_id:str,\n               session:Optional[aiohttp.client.ClientSession]=None,\n               debug_api:bool=False)\n\nget the completion status of an index\n\n# #| export\n# def generate_list_partitions_body(limit=100, offset=0):\n#     return {\n#         \"paginationFields\": [{\n#             \"fieldName\": \"datecompleted\",\n#             \"sortOrder\": \"DESC\",\n#             \"filterValues\": {\n#                 \"MIN\": None,\n#                 \"MAX\": None\n#             }\n#         }],\n#         \"limit\": 1000,\n#         \"offset\": 0\n#     }\n\n\n# #| export\n# async def list_partitions(full_auth: DomoFullAuth,\n#                           dataset_id: str,\n#                           body: dict = None,\n#                           maximum: int = None,\n#                           loop_until_end: bool = True,\n#                           session: aiohttp.ClientSession = None,\n#                           debug: bool = False):\n#     try:\n\n#         is_close_session = False if session else True\n\n#         if not session:\n#             session = aiohttp.ClientSession()\n\n#         body = body or generate_list_partitions_body()\n\n#         url = f\"https://{full_auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/partition/list\"\n\n#         offset_params = {\n#             'offset': 'offset',\n#             'limit': 'limit',\n#         }\n\n#         def arr_fn(res) -> list[dict]:\n#             return res.response\n\n#         res = await looper(auth=full_auth,\n#                            method='POST',\n#                            url=url,\n#                            arr_fn=arr_fn,\n#                            body=body,\n#                            offset_params_in_body=True,\n#                            offset_params=offset_params,\n#                            loop_until_end=True,\n#                            session=session,\n#                            debug=debug)\n\n#         if isinstance(res, list):\n#             return ResponseGetData(status=200,\n#                                    response=res,\n#                                    is_success=True)\n#         else:\n#             return ResponseGetData(status=400,\n#                                    response=None,\n#                                    is_success=False)\n\n#     finally:\n#         if is_close_session:\n#             await session.close()\n\n# # Delete partition has 3 stages\n# # Stage 1. This marks the data version associated with the partition tag as deleted.  It does not delete the partition tag or remove the association between the partition tag and data version.  There should be no need to upload an empty file – step #3 will remove the data from Adrenaline.\n\n\n# #| export\n# async def delete_partition_stage_1(full_auth: DomoFullAuth,\n#                                    dataset_id: str,\n#                                    dataset_partition_id: str,\n#                                    session: aiohttp.ClientSession = None,\n#                                    debug: bool = False):\n\n#     #url = f'https://{full_auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/partition/{dataset_partition_id}'\n#     # update on 9/9/2022 based on the conversation with Greg Swensen\n#     url = f'https://{full_auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/tag/{dataset_partition_id}/data'\n\n#     return await get_data(\n#         auth=full_auth,\n#         method=\"DELETE\",\n#         url=url,\n#         session=session,\n#         debug=debug\n#     )\n# # Stage 2. This will remove the partition association so that it doesn’t show up in the list call.  Technically, this is not required as a partition against a deleted data version will not count against the 400 partition limit, but as the current partitions api doesn’t make that clear, cleaning these up will make it much easier for you to manage.\n\n\n# #| export\n# async def delete_partition_stage_2(full_auth: DomoFullAuth,\n#                                    dataset_id: str,\n#                                    dataset_partition_id: str,\n#                                    session: aiohttp.ClientSession = None,\n#                                    debug: bool = False):\n\n#     url = f'https://{full_auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/partition/{dataset_partition_id}'\n\n#     return await get_data(\n#         auth=full_auth,\n#         method=\"DELETE\",\n#         url=url,\n#         session=session,\n#         debug=debug\n#     )\n\n\n# #| export\n# async def delete(full_auth: DomoFullAuth,\n#                  dataset_id: str, session: aiohttp.ClientSession = None, debug: bool = False):\n#     url = f\"https://{full_auth.domo_instance}.domo.com/api/data/v3/datasources/{dataset_id}?deleteMethod=hard\"\n\n#     return await get_data(\n#         auth=full_auth,\n#         method=\"DELETE\",\n#         url=url,\n#         session=session,\n#         debug=debug\n#     )"
  },
  {
    "objectID": "client/domoauth.html",
    "href": "client/domoauth.html",
    "title": "DomoAuth",
    "section": "",
    "text": "Stand alone functions for users who prefer a functional programming approach\n\n\n\nsource\n\n\n\n get_full_auth (domo_instance:str, domo_username:str, domo_password:str,\n                session:Optional[aiohttp.client.ClientSession]=None)\n\nuses username and password authentication to retrieve a full_auth access token\n\n\n\nimport os\n\nres = await get_full_auth(\n    domo_instance=\"domo-dojo\",\n    domo_username=\"test@test.com\",\n    domo_password=\"fake password\",\n)\nres\n\nResponseGetData(status=200, response={'success': False, 'reason': 'INVALID_CREDENTIALS'}, is_success=True)\n\n\n\nres = await get_full_auth(domo_instance=\"test\",\n                          domo_username=\"fake@test.com\", \n                          domo_password=\"fake password\")\nres\n\nResponseGetData(status=403, response='Forbidden', is_success=False, auth=None)\n\n\nThe 403 response is expected because test.domo.com presumeably does not exist or access if forbidden.\n\n\n\n\n\n\nsource\n\n\n\n get_developer_auth (domo_client_id:str, domo_client_secret:str,\n                     session:Optional[aiohttp.client.ClientSession]=None)\n\nonly use for authenticating against apis documented under developer.domo.com\n\n\nThe 401 response is expected because we are using invalid credentials\n\nawait get_developer_auth(domo_client_id=\"test_id\",\n                         domo_client_secret=\"test_secret\"\n                         )\n\nResponseGetData(status=401, response='Unauthorized', is_success=False, auth=None)\n\n\n\n\n\n\n\nThis access_token based authentication assumes the user has been provided a valid access token from Domo > Admin > Authentication > Access Token so authentication routes are actually not required.\nPer the Domo JavaCLI implementation, users can test the validity of the access_token agains the ‘me’ API\n!! Note about the Me API !! It appears that access_token authentication will direct the\n\nsource\n\n\n\n test_access_token (domo_access_token:str, domo_instance:str,\n                    session:Optional[aiohttp.client.ClientSession]=None)\n\nwill attempt to validate against the ‘me’ API. This is the same authentication test the Domo Java CLI uses.\n\n\n\nimport os\n\nawait test_access_token(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN']\n)\n\nResponseGetData(status=200, response={'id': 1893952720, 'invitorUserId': 587894148, 'displayName': 'Jae Wilson', 'userName': 'jae@onyxreporting.com', 'emailAddress': 'jae@onyxreporting.com', 'avatarKey': 'c605f478-0cd2-4451-9fd4-d82090b71e66', 'accepted': True, 'userType': 'USER', 'modified': 1651692505000, 'created': 1588960518, 'role': 'Admin', 'rights': 63, 'active': True, 'pending': False, 'systemUser': False, 'anonymous': False}, is_success=True)"
  },
  {
    "objectID": "client/domoauth.html#domoauth-error-classes",
    "href": "client/domoauth.html#domoauth-error-classes",
    "title": "DomoAuth",
    "section": "DomoAuth Error Classes",
    "text": "DomoAuth Error Classes\n\nsource\n\nInvalidInstanceError\n\n InvalidInstanceError (status:Optional[int]=None, message='invalid\n                       instance', domo_instance:Optional[str]=None)\n\nreturn if invalid domo_instance sent to API\n\nsource\n\n\nInvalidCredentialsError\n\n InvalidCredentialsError (status:Optional[int]=None, message='invalid\n                          credentials', domo_instance:Optional[str]=None)\n\nreturn invalid credentials sent to API\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nstatus\nOptional\nNone\nAPI request status\n\n\nmessage\nstr\ninvalid credentials\n\n\n\ndomo_instance\nOptional\nNone"
  },
  {
    "objectID": "client/domoauth.html#domofullauth",
    "href": "client/domoauth.html#domofullauth",
    "title": "DomoAuth",
    "section": "DomoFullAuth",
    "text": "DomoFullAuth\n\nsource\n\nDomoFullAuth\n\n DomoFullAuth (domo_instance:str, domo_username:str, domo_password:str,\n               token:Optional[str]=None, token_name:Optional[str]=None,\n               user_id:Optional[str]=None, auth_header:dict=<factory>,\n               url_manual_login:Optional[str]=None)\n\nuse for full authentication token\n\nsample implementations of DomoFullAuth\n\ntry:\n    full_auth = DomoFullAuth(domo_instance=\"domo-dojo\",\n                             domo_username=\"test12@domo.com\",\n                             domo_password=\"test1234\")\n    res = await full_auth.get_auth_token()\n\nexcept InvalidCredentialsError as e:\n    print(e)\n\nStatus 200 - INVALID_CREDENTIALS at domo-dojo\n\n\n\ntry:\n    full_auth = DomoFullAuth(domo_instance=\"test\",\n                             domo_username=\"test12@domo.com\",\n                             domo_password=\"test1234\")\n    await full_auth.get_auth_token()\nexcept InvalidInstanceError as e:\n    print(e)\n\nStatus 403 - INVALID INSTANCE at test"
  },
  {
    "objectID": "client/domoauth.html#domotokenauth",
    "href": "client/domoauth.html#domotokenauth",
    "title": "DomoAuth",
    "section": "DomoTokenAuth",
    "text": "DomoTokenAuth\n\nsource\n\nDomoTokenAuth\n\n DomoTokenAuth (domo_instance:str, domo_access_token:str,\n                token:Optional[str]=None, token_name:Optional[str]=None,\n                user_id:Optional[str]=None, auth_header:dict=<factory>,\n                url_manual_login:Optional[str]=None)\n\nuse for access_token authentication. Tokens are generated in domo > admin > access token Necessary in cases where direct sign on is not permitted\n\nSample implementation of DomoTokenAuth\n\ntry:\n    domo_auth = DomoTokenAuth(domo_instance=\"domo-dojo\",\n                              domo_access_token='fake password')\n    token = await domo_auth.get_auth_token()\n    print(domo_auth)\n\nexcept InvalidCredentialsError as e:\n    print(e)\n\nStatus 401 - Unauthorized at domo-dojo"
  },
  {
    "objectID": "client/domoauth.html#domodeveloperauth",
    "href": "client/domoauth.html#domodeveloperauth",
    "title": "DomoAuth",
    "section": "DomoDeveloperAuth",
    "text": "DomoDeveloperAuth\n\nsource\n\nDomoDeveloperAuth\n\n DomoDeveloperAuth (domo_client_id:str, domo_client_secret:str)\n\nuse for full authentication token\n\nSample implementations of DomoDeveloperAuth\n\ndomo_client_id = \"test_client\"\ndomo_client_secret = \"test_secret\"\n\ntry:\n    domo_auth = DomoDeveloperAuth(domo_client_id, domo_client_secret)\n    await domo_auth.get_auth_token()\nexcept InvalidCredentialsError as e:\n    print(e)\n\nStatus 401 - Unauthorized"
  },
  {
    "objectID": "index.html#section",
    "href": "index.html#section",
    "title": "domolibrary: a powerful pydomo alternative",
    "section": "",
    "text": "For each task, consider the appropriate DomoAuth mechanism. In most cases DomoFullAuth or DomoTokenAuth will be appropriate if you’re\n\n1+1\n\n2"
  },
  {
    "objectID": "index.html#authentication",
    "href": "index.html#authentication",
    "title": "domolibrary: a powerful pydomo alternative",
    "section": "Authentication",
    "text": "Authentication\nFor each task, consider the appropriate DomoAuth mechanism. In most cases DomoFullAuth or DomoTokenAuth will be appropriate as this library predominately accesses private APIs. Any Public routes or methods will be labeled appropriately in which case you should use DomoClientAuth\nTypically each project will begin with configuring an auth object. If you are accessing multiple Domo instances, you’ll probably need multiple auth objects.\n\n# configure an auth method\nimport os\nimport domolibrary.client.DomoAuth as dmda\n\ntoken_auth = dmda.DomoTokenAuth( domo_instance = 'domo-dojoo', domo_access_token = os.environ['DOMO_DOJO_ACCESS_TOKEN'])"
  }
]